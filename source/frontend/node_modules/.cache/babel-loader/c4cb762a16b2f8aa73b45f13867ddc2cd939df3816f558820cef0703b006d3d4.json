{"ast":null,"code":"// L'URL di base ora punta sempre all'API Gateway\nconst API_GATEWAY_URL = 'http://localhost:9000';\n\n/**\n * Funzione helper per tutte le chiamate API.\n * Aggiunge l'header di autorizzazione se è presente un token.\n * Gestisce la logica di base della richiesta e degli errori.\n * È esportata per essere usata da altri file API (es. userApi.js).\n */\nexport async function apiRequest(path, options = {}) {\n  const token = localStorage.getItem('authToken');\n  const headers = {\n    'Content-Type': 'application/json',\n    ...options.headers\n  };\n\n  // --- ADD THIS BLOCK ---\n  // If we are sending FormData (like a file), we MUST let the browser\n  // set the Content-Type header itself (so it can add the 'boundary').\n  if (options.body instanceof FormData) {\n    delete headers['Content-Type'];\n  }\n  // --- END OF NEW BLOCK ---\n\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  const response = await fetch(`${API_GATEWAY_URL}${path}`, {\n    ...options,\n    headers\n  });\n  if (!response.ok) {\n    // Tenta di leggere il corpo dell'errore, altrimenti usa lo status\n    const errorBody = await response.json().catch(() => ({\n      message: `HTTP Error: ${response.status}`\n    }));\n    // Check for the \"error\" key from your gateway filter\n    throw new Error(errorBody.error || errorBody.message || 'Qualcosa è andato storto');\n  }\n\n  // Evita errori se la risposta non ha corpo (es. su DELETE o Logout)\n  const text = await response.text();\n  return text ? JSON.parse(text) : {};\n}\n\n/**\n * Esegue il login e salva il token e i dati utente.\n * @returns {Promise<any>} I dati dell'utente.\n */\nexport async function login(username, password) {\n  const response = await apiRequest('/auth/login', {\n    method: 'POST',\n    body: JSON.stringify({\n      username,\n      password\n    })\n  });\n\n  // Salva solo il token. L'app recupererà l'utente separatamente.\n  if (response && response.token) {\n    localStorage.setItem('authToken', response.token);\n  } else {\n    localStorage.removeItem('authToken');\n    throw new Error(\"La risposta del login non è valida.\");\n  }\n  // Non restituisce più l'utente\n}\n\n/**\n * Esegue il logout pulendo il localStorage.\n * Non è necessario chiamare un endpoint se il backend è stateless (JWT).\n */\nexport function logout() {\n  localStorage.removeItem('authToken');\n  localStorage.removeItem('currentUser');\n}\n\n/**\n * Chiama l'endpoint di registrazione.\n */\nexport async function register(user) {\n  // 1. CHIAMATA A /auth/register (come da filtro gateway)\n  const response = await apiRequest('/auth/register', {\n    method: 'POST',\n    body: JSON.stringify(user)\n  });\n\n  // 2. SALVA IL TOKEN\n  if (response && response.token) {\n    localStorage.setItem('authToken', response.token);\n  } else {\n    throw new Error(\"La risposta della registrazione non è valida.\");\n  }\n}\n\n/**\n* Verifica se il token è valido chiamando il nuovo endpoint.\n * @returns {Promise<any>} Dati di validazione: { valid: true, userId: \"1\", ... }\n */\nexport async function checkLoginStatus() {\n  // 3. CHIAMA /auth/validate\n  return apiRequest('/auth/validate');\n}","map":{"version":3,"names":["API_GATEWAY_URL","apiRequest","path","options","token","localStorage","getItem","headers","body","FormData","response","fetch","ok","errorBody","json","catch","message","status","Error","error","text","JSON","parse","login","username","password","method","stringify","setItem","removeItem","logout","register","user","checkLoginStatus"],"sources":["/Users/onorio21/VSCode/NuwHarmonics/1892929_NewHarmonics/newharmonics/src/api/api.js"],"sourcesContent":["// L'URL di base ora punta sempre all'API Gateway\nconst API_GATEWAY_URL = 'http://localhost:9000';\n\n/**\n * Funzione helper per tutte le chiamate API.\n * Aggiunge l'header di autorizzazione se è presente un token.\n * Gestisce la logica di base della richiesta e degli errori.\n * È esportata per essere usata da altri file API (es. userApi.js).\n */\nexport async function apiRequest(path, options = {}) {\n    const token = localStorage.getItem('authToken');\n    const headers = {\n        'Content-Type': 'application/json',\n        ...options.headers,\n    };\n\n    // --- ADD THIS BLOCK ---\n    // If we are sending FormData (like a file), we MUST let the browser\n    // set the Content-Type header itself (so it can add the 'boundary').\n    if (options.body instanceof FormData) {\n        delete headers['Content-Type'];\n    }\n    // --- END OF NEW BLOCK ---\n\n    if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    const response = await fetch(`${API_GATEWAY_URL}${path}`, {\n        ...options,\n        headers,\n    });\n\n    if (!response.ok) {\n        // Tenta di leggere il corpo dell'errore, altrimenti usa lo status\n        const errorBody = await response.json().catch(() => ({ message: `HTTP Error: ${response.status}` }));\n        // Check for the \"error\" key from your gateway filter\n        throw new Error(errorBody.error || errorBody.message || 'Qualcosa è andato storto');\n    }\n\n    // Evita errori se la risposta non ha corpo (es. su DELETE o Logout)\n    const text = await response.text();\n    return text ? JSON.parse(text) : {};\n}\n\n/**\n * Esegue il login e salva il token e i dati utente.\n * @returns {Promise<any>} I dati dell'utente.\n */\nexport async function login(username, password) {\n    const response = await apiRequest('/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({ username, password }),\n    });\n\n    // Salva solo il token. L'app recupererà l'utente separatamente.\n    if (response && response.token) {\n        localStorage.setItem('authToken', response.token);\n    } else {\n        localStorage.removeItem('authToken');\n        throw new Error(\"La risposta del login non è valida.\");\n    }\n    // Non restituisce più l'utente\n}\n\n/**\n * Esegue il logout pulendo il localStorage.\n * Non è necessario chiamare un endpoint se il backend è stateless (JWT).\n */\nexport function logout() {\n    localStorage.removeItem('authToken');\n    localStorage.removeItem('currentUser');\n}\n\n/**\n * Chiama l'endpoint di registrazione.\n */\nexport async function register(user) {\n    // 1. CHIAMATA A /auth/register (come da filtro gateway)\n    const response = await apiRequest('/auth/register', {\n        method: 'POST',\n        body: JSON.stringify(user),\n    });\n\n    // 2. SALVA IL TOKEN\n    if (response && response.token) {\n        localStorage.setItem('authToken', response.token);\n    } else {\n        throw new Error(\"La risposta della registrazione non è valida.\");\n    }\n}\n\n/**\n* Verifica se il token è valido chiamando il nuovo endpoint.\n * @returns {Promise<any>} Dati di validazione: { valid: true, userId: \"1\", ... }\n */\nexport async function checkLoginStatus() {\n    // 3. CHIAMA /auth/validate\n    return apiRequest('/auth/validate');\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}